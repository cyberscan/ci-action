#! /usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Dec 02 2021

Copyright (c) 2021 Deutsche Gesellschaft fÃ¼r Cybersicherheit mbH & Co. KG

@author Merlin Mittelbach

different file parsers
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from json import load as json_load
from logging import getLogger
from typing import Any, ClassVar, Dict, List, TextIO, Union

logger = getLogger(__file__)


class Parser(ABC):
    @abstractmethod
    def parse(self, file_handler: TextIO) -> None:
        ...


class CoverageReporter(Parser, ABC):
    @abstractmethod
    def get_relative_coverage(self, metric: str) -> int:
        ...


@dataclass
class JestCoverageJsonSummaryParser(CoverageReporter):
    """Parse jest code coverage reports generated by
    JsonSummary reporter.
    """
    total: Dict[str, Dict[str, Union[int, float]]] = \
        field(init=False, repr=False)
    files: Dict[str, Any] = field(init=False, repr=False)
    metrics: ClassVar[List[str]] = [
        "statements", "lines", "branches", "functions"
    ]

    def __post_init__(self):
        logger.debug("Created %s.", repr(self))

    def parse(self, file_handler: TextIO) -> int:
        report: Dict[str, Any] = json_load(file_handler)
        self.total = report["total"]
        del report["total"]
        self.files = report
        logger.debug("Parsed file by %s.", repr(self))

    def get_relative_coverage(self, metric: str) -> int:
        if metric not in self.metrics:
            raise ValueError("Unknown metric.")
        return int(self.total[metric]["pct"])


@dataclass
class PythonCoverageParser(CoverageReporter):
    """Parse python coverage reports generated by
    coverage.io.
    """
    total: Dict[str, Dict[str, Union[int, float]]] = \
        field(init=False, repr=False)
    files: Dict[str, Any] = field(init=False, repr=False)
    metadata: Dict[str, Any] = field(init=False, repr=False)
    metrics: ClassVar[List[str]] = [
        "statements", "lines", "branches"
    ]

    def __post_init__(self):
        logger.debug("Created %s.", repr(self))

    def parse(self, file_handler: TextIO) -> int:
        report: Dict[str, Any] = json_load(file_handler)
        self.total = report["totals"]
        self.files = report["files"]
        self.metadata = report["meta"]
        logger.debug("Parsed file by %s.", repr(self))

    def get_relative_coverage(self, metric: str) -> int:
        if metric == "statements":
            return int(self.total["percent_covered"])
        elif metric == "lines":
            return int(
                self.total["covered_lines"]*100 /
                (self.total["covered_lines"]+self.total["missing_lines"])
            )
        elif metric == "branches":  # branches
            return int(
                self.total["num_branches"]*100/self.total["covered_branches"]
            )
        else:
            raise ValueError("Unknown metric.")


REGISTERED_PARSERS = {
    "jest-coverage": JestCoverageJsonSummaryParser,
    "python-coverage": PythonCoverageParser
}
